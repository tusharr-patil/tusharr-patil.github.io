[{"categories":["Algorithms"],"content":"A* Algorithm: Combining Speed and Accuracy A* Star Algorithm helps us find the shortest path in a graph, often faster than traditional algorithms like BFS or Dijkstra’s Algorithm. Both BFS and Dijkstra’s Algorithm have their strengths, but they can be slow, especially when dealing with complex graphs.\nThe Need for Speed and Accuracy The problem with BFS is its lack of intelligence. It explores every node without considering their relevance to the destination. Dijkstra’s Algorithm is an improvement but can still visit unnecessary nodes.\nWhen dealing with massive graphs, like the ones Google Maps handles, speed becomes crucial. This is where A* Algorithm shines.\nHow A* Algorithm Works A* Algorithm is similar to Dijkstra’s but adds a touch of intelligence. It judges whether a node is close to the destination, making it faster.\nFormula: Cost = Distance(start_node, current_node) + Heuristic(current_node, destination_node) Cost: Total cost of the current node. Distance(start_node, current_node): Actual distance between start_node and current_node. Heuristic(current_node, destination_node): Estimated distance from current_node to destination_node. Heuristic Function The heuristic function provides an approximate distance from point A to point B. One common heuristic is Euclidean Distance:\nh(n) = sqrt((x₂ - x₁)² + (y₂ - y₁)²) Java Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 public class Main { public static void main(String[] args) { AStar algo = new AStar(); // 0 - accessible, 1 - obstacle int[][] graph1 = { {0, 0, 0, 1, 0}, {0, 0, 0, 1, 0}, {0, 1, 0, 1, 0}, {0, 1, 0, 1, 0}, {0, 1, 0, 0, 0} }; int shortestDistance1 = algo.ETA(graph1, 0, 0, 4, 4); System.out.println(\"Shortest Distance: \" + shortestDistance1); } } class AStar { class Node { int x, y; int cost; // g(n) + h(n) int dist; // g(n) List\u003cString\u003e list; public Node(int x, int y, int cost, int dist, List\u003cString\u003e list) { this.x = x; this.y = y; this.cost = cost; this.dist = dist; this.list = list; } } private int[] ROWS = {0, 1, 0, -1, 1, 1, -1, -1}; private int[] COLS = {1, 0, -1, 0, 1, -1, 1, -1}; public int ETA(int[][] graph, int s1, int s2, int d1, int d2) { // rows, cols int n = graph.length, m = graph[0].length; // obstacle is present at source or destination if(graph[s1][s2] == 1 || graph[d1][d2] == 1) return -1; // node with less cost gets preference PriorityQueue\u003cNode\u003e pq = new PriorityQueue\u003c\u003e((x, y) -\u003e x.cost - y.cost); List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(s1 + \"|\" + s2); pq.add(new Node(s1, s2, 0, 0, list)); Set\u003cString\u003e visitedNodes = new HashSet\u003c\u003e(); visitedNodes.add(s1 + \"|\" + s2); while(!pq.isEmpty()) { Node curr = pq.poll(); int c1 = curr.x, c2 = curr.y, co = curr.cost; if(c1 == d1 \u0026\u0026 c2 == d2) { System.out.println(curr.list); return curr.dist; } // find the neighbours - assuming we can go in eight directions for(int dir = 0; dir \u003c 8; dir++) { int nextRow = c1 + ROWS[dir]; int nextCol = c2 + COLS[dir]; // next node must be valid node if(nextRow \u003c 0 || nextCol \u003c 0 || nextRow \u003e= n || nextCol \u003e= m || graph[nextRow][nextCol] == 1 || visitedNodes.contains(nextRow + \"|\" + nextCol)) continue; // considering 1 as distance between any two nodes int totalDist = curr.dist + 1; int cost = totalDist + heuristic(nextRow, nextCol, d1, d2); List\u003cString\u003e newList = new ArrayList\u003c\u003e(curr.list); newList.add(nextRow + \"|\" + nextCol); pq.add(new Node(nextRow, nextCol, cost, totalDist, newList)); visitedNodes.add(nextRow + \"|\" + nextCol); } } // no path found return -1; } private int heuristic(int s1, int s2, int d1, int d2) { return (int)(Math.sqrt(Math.pow(d1-s1, 2) + Math.pow(d2-s2, 2))); } } This is very similar to Dijkstra, but what really adds intelligence to this algorithm is Heuristic function.\nLet’s see the difference:\nDijkstra’s Algorithm A* Algorithm Resources:\nhttp://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html A* star wiki Dijkstra wiki ","tags":["Algorithms","System Design"],"title":"A* Algorithm","uri":"/posts/a_star_algo/"},{"categories":["System Design Fundamentals"],"content":"Consistency refers to how fresh a particular piece of data is. Technically speaking, every read requests we receive to our distrubuted severs, must return same piece of data.\nConsistency levels refers to how fresh we want our data to be, when a user sends a read request. There will be a tradeoff between consistency and efficiency in Consistency Levels. So, it is necessary to choose the consistency level depending upon the requirement.\nLinearizable/Atomic Consistency For every read request we receive, we want to show fresh data.\nTo achieve this, every request (read or write) must be in order. And to maintain the order, we use a single threaded single sever.\nThis will have strong consistency. But the efficiency is lowest.\nUsecase: Banking Transactions, Product Availability Update, etc.\nEventual Consistency For a read request, we will send stale data, but eventually when the data gets updated, we will send fresh data.\nThe system is not consistency in the beginning, but eventually, it will have consistency.\nTo achieve this, we can process requests parallely (using multiple severs) or concurrently (using multiple threads).\nThe consistency is lowest, but efficiency is highest.\nUsecase: Like, Comments, DNS, Sharing Post on social apps, etc.\nCausal Consistency Based upon the relation of operations, we execute the related operations in order.\nWe can find the relation of operations by checking the type of data on which the operations are doing read/write operation.\nIf we have two operations:\nwrite x = ‘John’ read x Notice, that both requests are going to perform operation on same data item. So, we will execute these two requests in order in a server/thread.\nBut, if we have:\nwrite x = ‘John’ write y = ‘Cena’ Notice, that both requests are performing operation on different piece of data item, so we will execute these two requests on seperate server/thread.\nCausal Consistency is better than Linearizable interms of efficiency and Eventual Consistency in terms of consistency.\nBut the drawback is that the Causal Consistency will fail for aggregation, and will showstale data for aggregation operations.\nThe reason why it fails is because it will not be able to find relationship between aggregation operations, and it might treat the aggregation operation as related.\nUsecase: Google Docs (multiple edits), chat systems, multi-player games, etc.\n","tags":["System Design","CS Fundamentals"],"title":"Consistency Levels in Distrubuted System","uri":"/posts/data-consistency/"},{"categories":null,"content":"Hello World, I will be sharing poorly written blogs on topics like System Design, Algorithms \u0026 some productivity stuff.\n","tags":null,"title":"Hello World","uri":"/posts/hello-world/"}]
